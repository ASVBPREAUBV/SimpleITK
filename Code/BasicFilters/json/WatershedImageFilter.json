{
  "name" : "WatershedImageFilter",
  "template_code_filename" : "ImageFilter",
  "template_test_filename" : "ImageFilter",
  "number_of_inputs" : 1,
  "doc" : "Docs",
  "pixel_types" : "BasicPixelIDTypeList",
  "filter_type" : "itk::WatershedImageFilter< InputImageType >",
  "members" : [
    {
      "name" : "Threshold",
      "type" : "double",
      "default" : "0.0",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set/Get the input thresholding parameter. Units are a percentage of the maximum depth in the image.",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : "Set/Get the input thresholding parameter. Units are a percentage of the maximum depth in the image."
    },
    {
      "name" : "Level",
      "type" : "double",
      "default" : "0.0",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set/Get the flood level for generating the merge tree from the initial segmentation",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : "Set/Get the input thresholding parameter. Units are a percentage of the maximum depth in the image."
    }
  ],
  "tests" : [
    {
      "tag" : "defaults",
      "description" : "Simply run with default settings",
      "settings" : [],
      "md5hash" : "ba34f1cbb75e6f6f93f490b05fb4458d",
      "inputs" : [
        "Input/cthead1-grad-mag.mha"
      ]
    },
    {
      "tag" : "level_and_threshold",
      "description" : "setting level and threshold parameters",
      "settings" : [
        {
          "parameter" : "Level",
          "value" : "0.1"
        },
        {
          "parameter" : "Threshold",
          "value" : "0.1"
        }
      ],
      "md5hash" : "30d10cd0020a609053408754de1e7a3f",
      "inputs" : [
        "Input/cthead1-grad-mag.mha"
      ]
    }
  ],
  "itk_module" : "ITKWatersheds",
  "itk_group" : "Watersheds",
  "detaileddescription" : "\\par Overview and terminology\n\n\n\\par \nThis filter implements a non-streaming version of an image segmentation algorithm commonly known as \"watershed segmentation\". Watershed segmentation gets its name from the manner in which the algorithm segments regions into catchment basins. If a function \\f$ f \\f$ is a continuous height function defined over an image domain, then a catchment basin is defined as the set of points whose paths of steepest descent terminate at the same local minimum of \\f$ f \\f$ .\n\n\\par \nThe choice of height function (input) depends on the application, and the basic watershed algorithm operates independently of that choice. For intensity-based image data, you might typically use some sort of gradient magnitude calculation as input. (see itk::GradientMagnitudeImageFilter )\n\n\\par \nThe watershed algorithm proceeds in several steps. First, an initial classification of all points into catchment basin regions is done by tracing each point down its path of steepest descent to a local minima. Next, neighboring regions and the boundaries between them are analyzed according to some saliency measure (such as minimum boundary height) to produce a tree of merges among adjacent regions. These merges occur at different maximum saliency values. The collective set of all possible merges up to a specified saliency \"flood level\" is referred to in this documentation as a \"merge tree\". Metaphorically, the flood level is a value that reflects the amount of precipitation that is rained into the catchment basins. As the flood level rises, boundaries between adjacent segments erode and those segments merge. The minimum value of the flood level is zero and the maximum value is the difference between the highest and lowest values in the input image.\n\n\\par \nNote that once the initial analysis and segmentation is done to produce the merge tree, it is trivial to produce a hierarchy of labeled images in constant time. The complexity of the algorithm is in the computation of the merge tree. Once that tree has been created, the initial segmented image can be relabeled to reflect any maximum saliency value found in the tree by simply identifying a subset of segment merges from the tree.\n\n\\par Implementational details\nThis filter is a wrapper for several lower level process objects (watershed algorithm components in the namespace \"watershed\"). For a more complete picture of the implementation, refer to the documentation of those components. The component classes were designed to operate in either a data-streaming or a non-data-streaming mode. The pipeline constructed in this class' GenerateData() method does not support streaming, but is the common use case for the components.\n\n\\par Description of the input to this filter\nThe input to this filter is a scalar itk::Image of any dimensionality. This input image is assumed to represent some sort of height function or edge map based on the original image that you want to segment (such as would be produced by itk::GradientMagnitudeImageFilter ). This filter does not do any pre-processing on its input other than a thresholding step. The algorithm does not explicitly require that the input be of any particular data type, but floating point or double precision data is recommended.\n\n\\par \nThe recommended pre-processing for scalar image input to this algorithm is to use one of the itk::AnisotropicDiffusionImageFilter subclasses to smooth the original image and then perform some sort of edge calculation based on gradients or curvature.\n\n\\par Description of the output of this filter\nThis filter will produce an itk::Image of IdentifierType integer type and of the same dimensionality as the input image. The IdentifierType output image is referred to as the \"labeled image\" in this documentation. Each pixel in the image is assigned an IdentifierType integer label that groups it within a connected region.\n\n\\par Some notes on filter parameters\nTwo parameters control the output of this filter, Threshold and Level. The units of both parameters are percentage points of the maximum height value in the input.\n\n\\par \nThreshold is used to set the absolute minimum height value used during processing. Raising this threshold percentage effectively decreases the number of local minima in the input, resulting in an initial segmentation with fewer regions. The assumption is that the shallow regions that thresholding removes are of of less interest.\n\n\\par \nThe Level parameter controls the depth of metaphorical flooding of the image. That is, it sets the maximum saliency value of interest in the result. Raising and lowering the Level influences the number of segments in the basic segmentation that are merged to produce the final output. A level of 1.0 is analogous to flooding the image up to a depth that is 100 percent of the maximum value in the image. A level of 0.0 produces the basic segmentation, which will typically be very oversegmented. Level values of interest are typically low (i.e. less than about 0.40 or 40% ), since higher values quickly start to undersegment the image.\n\n\\par \nThe Level parameter can be used to create a hierarchy of output images in constant time once an initial segmentation is done. A typical scenario might go like this: For the initial execution of the filter, set the Level to the maximum saliency value that you anticipate might be of interest. Once the initial Update() of this process object has finished, the Level can be manipulated anywhere below the initial setting without triggering a full update of the segmentation mini-pipeline. All that is now be required to produce the new output is a simple relabeling of the output image.\n\n\\par \nThreshold and Level parameters are controlled through the class' Get/SetThreshold() and Get/SetLevel() methods.\n\n\\par Notes on streaming the watershed segmentation code\nComing soon... 12/06/01",
  "briefdescription" : "A low-level image analysis algorithm that automatically produces a hierarchy of segmented, labeled images from a scalar-valued image input."
}
